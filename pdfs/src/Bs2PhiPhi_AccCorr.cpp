// -*- mode: c++ -*-
// 
// File Bs2PhiPhi_AccCorrMDF.cxx generated by TMultiDimFit::MakeRealCode
// on Thu Oct 18 18:13:48 2012
// ROOT version 5.28/00h
//
// This file contains the function 
//
//    double  Bs2PhiPhi_AccCorr::MDF(double *x); 
//
// For evaluating the parameterization obtained
// from TMultiDimFit and the point x
// 
// See TMultiDimFit class documentation for more information 
// 
#include "Bs2PhiPhi_AccCorr.h"
//
// Static data variables
//
int    Bs2PhiPhi_AccCorr::gNVariables    = 3;
int    Bs2PhiPhi_AccCorr::gNCoefficients = 35;
double Bs2PhiPhi_AccCorr::gDMean         = 0.363507;
// Assignment to mean vector.
double Bs2PhiPhi_AccCorr::gXMean[] = {
  3.33067e-16, -2.22045e-16, -4.44089e-16 };

// Assignment to minimum vector.
double Bs2PhiPhi_AccCorr::gXMin[] = {
  -0.8, -0.8, -2.51328 };

// Assignment to maximum vector.
double Bs2PhiPhi_AccCorr::gXMax[] = {
  1.06667, 1.06667, 3.35104 };

// Assignment to coefficients vector.
double Bs2PhiPhi_AccCorr::gCoefficient[] = {
  -0.00870871,
  -0.0213655,
  -0.00967297,
  -0.0255256,
  0.00714531,
  -0.00856298,
  0.0131312,
  0.00971497,
  -0.0124669,
  -0.0152428,
  0.00997166,
  -0.00685846,
  -0.00629358,
  -0.0117275,
  -0.00795488,
  0.00461416,
  -0.0036737,
  0.00692218,
  -0.0111395,
  0.00696101,
  -0.00357882,
  0.00651222,
  -0.00358005,
  -0.00193834,
  0.00319983,
  -0.00316893,
  0.00265417,
  0.00128742,
  0.00175116,
  0.00132908,
  -0.000675507,
  0.00106564,
  0.000327152,
  -0.000135296,
  0.000115835
 };

// Assignment to error coefficients vector.
double Bs2PhiPhi_AccCorr::gCoefficientRMS[] = {
  1.78606e-10,
  1.30874e-10,
  1.30864e-10,
  2.26171e-10,
  4.28469e-11,
  3.85033e-11,
  1.97698e-10,
  4.96708e-11,
  5.06357e-11,
  1.78094e-10,
  5.91742e-11,
  4.07173e-11,
  7.47283e-11,
  1.34665e-10,
  7.77427e-11,
  3.79258e-10,
  3.2261e-11,
  8.58521e-11,
  2.6755e-10,
  1.05835e-10,
  7.27231e-11,
  1.33901e-10,
  9.31106e-11,
  3.18952e-11,
  1.00767e-10,
  1.88892e-10,
  3.66183e-10,
  2.69672e-10,
  5.17119e-11,
  5.07297e-11,
  8.01016e-11,
  2.0888e-10,
  1.85394e-10,
  5.64805e-11,
  3.23304e-11
 };

// Assignment to powers vector.
// The powers are stored row-wise, that is
//  p_ij = Bs2PhiPhi_AccCorr::gPower[i * NVariables + j];
int    Bs2PhiPhi_AccCorr::gPower[] = {
  1,  1,  1,
  3,  1,  1,
  1,  3,  1,
  2,  3,  2,
  1,  1,  2,
  1,  1,  3,
  2,  1,  2,
  1,  2,  3,
  2,  1,  3,
  2,  2,  2,
  3,  1,  2,
  1,  1,  5,
  1,  5,  1,
  3,  1,  3,
  2,  1,  1,
  2,  2,  1,
  1,  1,  4,
  4,  1,  2,
  3,  2,  2,
  1,  4,  2,
  5,  1,  1,
  1,  3,  3,
  2,  3,  1,
  1,  4,  1,
  3,  2,  1,
  4,  2,  1,
  2,  2,  3,
  3,  3,  1,
  2,  1,  4,
  1,  2,  4,
  1,  2,  1,
  1,  2,  2,
  2,  4,  1,
  1,  3,  2,
  4,  1,  1
};

// 
// The method   double Bs2PhiPhi_AccCorr::MDF(double *x)
// 
double Bs2PhiPhi_AccCorr::MDF(double *x) {
  double returnValue = Bs2PhiPhi_AccCorr::gDMean;
  int    i = 0, j = 0, k = 0;
  for (i = 0; i < Bs2PhiPhi_AccCorr::gNCoefficients ; i++) {
    // Evaluate the ith term in the expansion
    double term = Bs2PhiPhi_AccCorr::gCoefficient[i];
    for (j = 0; j < Bs2PhiPhi_AccCorr::gNVariables; j++) {
      // Evaluate the polynomial in the jth variable.
      int power = Bs2PhiPhi_AccCorr::gPower[Bs2PhiPhi_AccCorr::gNVariables * i + j]; 
      double p1 = 1, p2 = 0, p3 = 0, r = 0;
      double v =  1 + 2. / (Bs2PhiPhi_AccCorr::gXMax[j] - Bs2PhiPhi_AccCorr::gXMin[j]) * (x[j] - Bs2PhiPhi_AccCorr::gXMax[j]);
      // what is the power to use!
      switch(power) {
      case 1: r = 1; break; 
      case 2: r = v; break; 
      default: 
        p2 = v; 
        for (k = 3; k <= power; k++) { 
          p3 = p2 * v;
          p3 = 2 * v * p2 - p1; 
          p1 = p2; p2 = p3; 
        }
        r = p3;
      }
      // multiply this term by the poly in the jth var
      term *= r; 
    }
    // Add this term to the final result
    returnValue += term;
  }
  return returnValue;
}

// EOF for Bs2PhiPhi_AccCorrMDF.cxx
